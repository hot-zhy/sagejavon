{"query": "JDK 和 JRE 有什么区别？", "raw_response": {"answer": "### JDK 和 JRE 的区别：\n- **JDK（Java Development Kit）** 包含了用于开发和编译Java程序的工具，如编译器（javac）、调试器和其他必要的工具。它还包括了JRE。\n- **JRE（Java Runtime Environment）** 是用于运行Java程序的环境，包括Java虚拟机（JVM）和类库。JRE没有开发工具，只能用于运行Java程序。\n", "source": []}}
{"query": "== 和 equals 的区别是什么？", "raw_response": {"answer": "在Java中，'==' 是用于比较两个对象的引用是否相同，而 'equals' 方法是用于比较两个对象的内容是否相同。'==' 比较的是对象的引用地址，而 'equals' 方法可以根据对象的实际内容来判断是否相等。", "source": []}}
{"query": "两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？", "raw_response": {"answer": "两个对象的 hashCode() 相同，并不一定意味着 equals() 也为 true。hashCode() 方法用于获取对象的哈希码，而 equals() 方法用于比较对象的内容是否相等。在一些情况下，不同的对象可能具有相同的哈希码，但它们的内容并不相同，因此 equals() 方法可能返回 false。", "source": ["https://liaoxuefeng.com/books/java/collection/hashcode/index.html"]}}
{"query": "final 在 Java 中有什么作用？", "raw_response": {"answer": "在Java中，`final`修饰符有很多作用，包括阻止类被继承、方法被覆写以及字段被重新赋值。通过`final`修饰`class`可以阻止被继承，通过`final`修饰`method`可以阻止被子类覆写，通过`final`修饰`field`可以阻止被重新赋值。", "source": ["https://liaoxuefeng.com/books/java/oop/basic/scope/index.html"]}}
{"query": "Math.round(-1.5) 等于多少？", "raw_response": {"answer": "Math.round(-1.5) 的结果是 -1。Math.round() 方法返回最接近参数的 long，四舍五入为最接近的整数。在这种情况下，-1.5 最接近的整数是 -1。", "source": ["https://liaoxuefeng.com/books/java/oop/core/utils/index.html"]}}
{"query": "String 属于基础的数据类型吗？", "raw_response": {"answer": "String 不属于基础的数据类型，而是属于引用类型。Java的基本数据类型包括整数类型（byte，short，int，long）、浮点数类型（float，double）、字符类型（char）和布尔类型（boolean）。String 是一个引用类型，它是 Java 中最常用的字符串类型。除了基本类型外，Java 的其他类型都是 class，包括 String、Object、Runnable、Exception 等。基本类型和引用类型在内存中的存储方式有所不同，基本类型直接存储值，而引用类型存储的是对象的地址。常量在定义时进行初始化后不可再次赋值。为了简化变量类型的声明，可以使用 var 关键字进行类型推断。详细信息可参考提供的文档。", "source": ["https://liaoxuefeng.com/books/java/quick-start/basic/var-type/index.html", "https://liaoxuefeng.com/books/java/reflection/class/index.html"]}}
{"query": "Java 中操作字符串都有哪些类？它们之间有什么区别？", "raw_response": {"answer": "在Java中，操作字符串的主要类包括：**String**、**StringBuilder**和**StringJoiner**。它们之间的区别主要在于可变性和线程安全性。`String`是不可变的，每次对`String`进行修改都会创建一个新的`String`对象，适合在不经常改变字符串的情况下使用。`StringBuilder`是可变的，适合在需要频繁修改字符串内容时使用，但是不是线程安全的。`StringJoiner`用于将多个字符串连接起来，可以指定分隔符和前缀后缀。详细信息可以查看[Java核心类](https://liaoxuefeng.com/books/java/oop/core/index.html)。", "source": ["https://liaoxuefeng.com/books/java/oop/core/index.html"]}}
{"query": "String str=\"i\"与 String str=new String(\"i\")一样吗？", "raw_response": {"answer": "在Java中，String str=\"i\";与String str=new String(\"i\");并不完全相同。String str=\"i\";是使用字符串字面值创建一个新的字符串对象，而String str=new String(\"i\");则是显式地使用构造函数创建一个新的字符串对象。这两种方式在某些情况下可能会有细微的差异，尤其是在处理字符串常量池时。详情可参考相关文档。", "source": []}}
{"query": "如何将字符串反转？", "raw_response": {"answer": "要将字符串反转，可以使用`StringBuilder`类的`reverse()`方法。首先，创建一个`StringBuilder`对象并传入需要反转的字符串，然后调用`reverse()`方法即可得到反转后的字符串。例如：\n\n- 创建`StringBuilder`对象：\n```java\nStringBuilder sb = new StringBuilder(\"Hello\");\n```\n- 反转字符串：\n```java\nsb.reverse();\n```\n- 获取反转后的字符串：\n```java\nString reversedString = sb.toString();\n```\n这样就可以实现字符串的反转。", "source": ["https://liaoxuefeng.com/books/java/oop/core/string-encoding/index.html"]}}
{"query": "String 类的常用方法都有哪些？", "raw_response": {"answer": "常用的String类方法包括：\n- `length()`：返回字符串的长度\n- `charAt(int index)`：返回指定索引处的字符\n- `indexOf(String str)`：返回指定子字符串第一次出现的索引\n- `substring(int beginIndex, int endIndex)`：返回指定索引范围内的子字符串\n- `toUpperCase()`：将字符串转换为大写\n- `toLowerCase()`：将字符串转换为小写\n- `trim()`：去除字符串两端的空白字符\n- `equals(Object obj)`：比较字符串是否相等\n- `startsWith(String prefix)`：检查字符串是否以指定前缀开头\n- `endsWith(String suffix)`：检查字符串是否以指定后缀结尾", "source": ["https://liaoxuefeng.com/books/java/introduction/index.html"]}}
{"query": "抽象类必须要有抽象方法吗？", "raw_response": {"answer": "抽象类必须要有抽象方法。抽象类是包含抽象方法的类，而抽象方法是没有具体实现的方法，需要在子类中实现。这是抽象类的特性之一，通过定义抽象方法，可以强制子类提供自己的实现。因此，抽象类必须至少包含一个抽象方法。", "source": []}}
{"query": "抽象类能使用 final 修饰吗？", "raw_response": {"answer": "抽象类可以使用final修饰。final修饰的抽象类表示该类不能被继承，即不能有子类。这样可以确保抽象类的设计不会被改变。", "source": []}}
{"query": "接口和抽象类有什么区别？", "raw_response": {"answer": "接口和抽象类在Java中有几个关键区别：\n- 接口中的方法默认是抽象的，而抽象类可以包含具体方法实现。\n- 类可以实现多个接口，但只能继承一个抽象类。\n- 接口用于定义行为规范，而抽象类用于表示类的层次结构。\n- 接口中的字段默认是常量，而抽象类可以包含非常量字段。\n- 接口中不能包含构造方法，而抽象类可以包含构造方法。\n- 接口中的方法访问修饰符默认为public，而抽象类中的方法可以有不同的访问修饰符。\n- 接口是一种更灵活的机制，允许类实现多个接口，而抽象类更适合用于构建类的层次结构。\n", "source": []}}
{"query": "Java 中 IO 流分为几种？", "raw_response": {"answer": "Java 中的 IO 流主要分为四种：字节流、字符流、字节缓冲流和字符缓冲流。字节流主要处理字节数据，而字符流则处理字符数据。字节缓冲流提供了缓冲功能，可以提高 IO 效率，而字符缓冲流则是对字符流的缓冲处理。详细内容可以参考 [19.3.6. 其他操作](https://liaoxuefeng.com/books/java/functional/stream/other/index.html)。", "source": ["https://liaoxuefeng.com/books/java/functional/stream/other/index.html"]}}
{"query": "BIO、NIO、AIO 有什么区别？", "raw_response": {"answer": "在Java中，BIO（Blocking I/O）、NIO（Non-blocking I/O）和AIO（Asynchronous I/O）是不同的I/O模型。它们之间的区别在于处理I/O操作的方式和效率。BIO是同步阻塞I/O，每个连接都需要独立的线程进行处理，当有大量连接时会导致线程数量增加，性能下降。NIO是同步非阻塞I/O，通过Selector实现多路复用，一个线程可以处理多个连接，提高了性能。AIO是异步非阻塞I/O，通过回调函数的方式处理I/O操作，不需要等待操作完成，可以提高系统的并发能力。总体而言，NIO和AIO相比BIO更适合高并发的场景。", "source": []}}
{"query": "Files 的常用方法都有哪些？", "raw_response": {"answer": "常用的 Files 方法包括：创建文件、删除文件、复制文件、移动文件、重命名文件等。可以使用 Java 中的 File 类和 Files 类来执行这些操作。", "source": ["https://liaoxuefeng.com/books/java/io/file/index.html"]}}
{"query": "Java 容器都有哪些？", "raw_response": {"answer": "Java 容器包括 ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap 等。", "source": ["https://liaoxuefeng.com/books/java/functional/stream/other/index.html"]}}
{"query": "Collection 和 Collections 有什么区别？", "raw_response": {"answer": "[Error] internal error occurred: 'float' object is not iterable", "source": []}}
{"query": "List、Set、Map 之间的区别是什么？", "raw_response": {"answer": "### List、Set、Map 之间的区别是什么？\n- **List**:\n  1. List是一个有序集合，可以包含重复元素。\n  2. 可以通过索引访问List中的元素。\n- **Set**:\n  1. Set是一个不包含重复元素的集合。\n  2. Set不保证元素的顺序，即不是有序的。\n- **Map**:\n  1. Map是一种键值对的集合，每个键最多只能映射到一个值。\n  2. Map中的键是唯一的，值可以重复。\n", "source": []}}
{"query": "HashMap 和 Hashtable 有什么区别？", "raw_response": {"answer": "在Java中，HashMap和Hashtable都是用于存储键值对的数据结构，它们之间的区别主要有以下几点：\n- **同步性**：Hashtable是同步的，适合在多线程环境下使用，而HashMap则是非同步的，性能更好但不适合多线程操作。\n- **空键值**：Hashtable不允许有null键和null值，而HashMap允许一个null键和多个null值。\n- **迭代器**：Hashtable的迭代器是通过Enumeration实现的，而HashMap的迭代器是通过Iterator实现的。\n- **继承**：Hashtable是Hashtable类的子类，而HashMap是AbstractMap类的子类。\n- **推荐使用**：一般情况下，推荐使用HashMap，除非需要在多线程环境下使用，这时可以选择Hashtable。\n这些是HashMap和Hashtable之间的主要区别。", "source": []}}
{"query": "如何决定使用 HashMap 还是 TreeMap？", "raw_response": {"answer": "在决定使用 HashMap 还是 TreeMap 时，主要考虑到两者的不同特点。HashMap 提供了快速的查找、插入和删除操作，时间复杂度为 O(1)，但不保证元素的顺序。TreeMap 则是基于红黑树实现的，可以按照键的自然顺序或者自定义顺序进行排序，查找、插入和删除操作的时间复杂度为 O(log n)。因此，如果需要快速的查找操作且不关心顺序，可以选择 HashMap；如果需要有序的键值对集合，可以选择 TreeMap。", "source": []}}
{"query": "HashMap 的实现原理？", "raw_response": {"answer": "HashMap 的实现原理涉及到哈希表的数据结构，它通过哈希函数将key映射到存储位置，实现快速的查找和插入操作。具体实现包括哈希桶数组、链表/红黑树解决哈希冲突、负载因子控制扩容等。详细内容可以参考 [Java核心技术](https://liaoxuefeng.com/books/java/unit-test/index.html)。", "source": ["https://liaoxuefeng.com/books/java/unit-test/index.html"]}}
{"query": "HashSet 的实现原理？", "raw_response": {"answer": "HashSet 是基于 HashMap 实现的，HashSet 内部使用 HashMap 来保存元素，将元素作为 key 存储在 HashMap 中，而 value 使用一个固定的 Object 对象。HashSet 的实现原理主要是利用 HashMap 的 key 值唯一性来保证集合中元素的唯一性。", "source": ["https://liaoxuefeng.com/books/java/collection/set/index.html"]}}
{"query": "ArrayList 和 LinkedList 的区别？", "raw_response": {"answer": "### ArrayList 和 LinkedList 的区别：\n\n- **获取指定元素**：ArrayList 速度很快，而 LinkedList 需要从头开始查找元素。\n- **添加元素到末尾**：ArrayList 和 LinkedList 都速度很快。\n- **在指定位置添加/删除**：ArrayList 需要移动元素，而 LinkedList 不需要移动元素。\n- **内存占用**：ArrayList 占用较少内存，而 LinkedList 占用较大内存。\n\n根据比较，通常情况下我们优先使用 ArrayList。\n\n**List的特点：**\n\n使用 List 时，可以添加重复的元素，即 List 内部的元素可以重复。例如，可以参考 [这个链接](https://liaoxuefeng.com/books/java/collection/list/index.html) 中的代码示例。\n", "source": ["https://liaoxuefeng.com/books/java/collection/list/index.html"]}}
{"query": "数组与 List 的转换方式？", "raw_response": {"answer": "要将数组转换为List，可以使用Arrays.asList()方法，例如：\n- 将数组转换为List：`List<Integer> list = Arrays.asList(array);`\n- 将List转换为数组，可以使用List的toArray()方法，例如：\n- 将List转换为数组：`Integer[] array = list.toArray(new Integer[0]);`\n", "source": ["https://liaoxuefeng.com/books/java/collection/index.html"]}}
{"query": "ArrayList 和 Vector 有什么区别？", "raw_response": {"answer": "ArrayList 和 Vector 有以下区别：\n- **同步性**：ArrayList 是非同步的，不是线程安全的，而 Vector 是同步的，是线程安全的。\n- **性能**：由于 Vector 是同步的，会导致一定的性能损失，而 ArrayList 没有这种性能损失。\n- **增长方式**：ArrayList 默认增长50%，而 Vector 默认增长100%。\n- **迭代器**：ArrayList 使用迭代器遍历，而 Vector 使用 Enumeration 进行遍历。\n- **是否遗留类**：Vector 是遗留类，而 ArrayList 是 Java 1.2 引入的新集合类。\n- **推荐使用**：一般情况下，推荐使用 ArrayList，除非需要线程安全的情况下才使用 Vector。", "source": ["https://liaoxuefeng.com/books/java/collection/list/index.html"]}}
{"query": "Array 和 ArrayList 的区别？", "raw_response": {"answer": "### Array 和 ArrayList 的区别\n- **Array**:\n  1. Array 是一个固定大小的数据结构，一旦创建后大小不可改变。\n  2. Array 中的元素必须是相同的数据类型。\n  3. Array 可以直接访问元素，但插入和删除元素会导致其他元素位置移动。\n- **ArrayList**:\n  1. ArrayList 是基于数组实现的动态数组，大小可以动态增长。\n  2. ArrayList 中的元素可以是不同的数据类型。\n  3. ArrayList 支持动态增加和删除元素，不会导致其他元素位置移动。\n", "source": []}}
{"query": "Queue 中 poll() 和 remove() 区别？", "raw_response": {"answer": "在 Java 中，Queue 中的 poll() 和 remove() 方法都用于从队列中获取并移除头部元素，但在队列为空时，poll() 方法会返回 null，而 remove() 方法会抛出异常。因此，主要区别在于处理空队列时的行为。", "source": []}}
{"query": "哪些集合类是线程安全的？", "raw_response": {"answer": "线程安全的集合类包括：**Vector**、**HashTable**、**ConcurrentHashMap**。这些集合类在多线程环境下可以安全地进行操作。", "source": ["https://liaoxuefeng.com/books/java/threading/index.html"]}}
{"query": "Iterator 是什么？", "raw_response": {"answer": "在Java中，Iterator是一个接口，用于遍历集合中的元素。通过Iterator接口，可以依次访问集合中的每个元素，而不需要了解集合的内部结构。使用Iterator可以实现对集合的安全遍历，避免在遍历过程中修改集合引发的异常。具体可以查阅[Java集合简介](https://liaoxuefeng.com/books/java/collection/quick-start/index.html)了解更多。", "source": ["https://liaoxuefeng.com/books/java/collection/quick-start/index.html"]}}
{"query": "Iterator 怎么使用？", "raw_response": {"answer": "迭代器是 Java 中用于遍历集合元素的接口，可以通过集合的 iterator() 方法获取迭代器实例，然后使用 hasNext() 和 next() 方法来依次访问集合中的元素。", "source": []}}
{"query": "Iterator 和 ListIterator 区别？", "raw_response": {"answer": "[Error] internal error occurred: 'float' object is not iterable", "source": []}}
{"query": "并行和并发有什么区别？", "raw_response": {"answer": "在计算机科学中，并行和并发是两个相关但不同的概念。**并行**是指系统同时执行多个任务，实际上同时处理多个任务。**并发**是指系统同时处理多个任务，但这些任务可能不是同时执行的，而是交替执行。简而言之，并行是指同时做很多事情，而并发是指同时管理很多事情。这两个概念在编程中具有重要意义，因为它们涉及到如何有效地利用计算资源。在Java中，并行通常指的是通过多线程同时执行多个任务，而并发则是指多个任务在同一时间段内交替执行。", "source": []}}
{"query": "线程和进程的区别？", "raw_response": {"answer": "在计算机科学中，线程和进程是操作系统中的重要概念。**线程**是进程中的实体，负责执行实际的工作。一个进程可以包含多个线程，它们共享进程的资源。**进程**是程序的执行实例，拥有独立的内存空间和系统资源。线程之间共享进程的内存空间，而进程之间是相互独立的。这是线程和进程的主要区别。", "source": []}}
{"query": "守护线程是什么？", "raw_response": {"answer": "守护线程是一种在Java多线程编程中的特殊线程类型，它的存在不会阻止JVM的关闭。当所有的非守护线程结束时，JVM会自动退出。守护线程通常用于在后台提供服务或执行任务，如垃圾回收线程就是一个典型的守护线程。", "source": ["https://liaoxuefeng.com/books/java/threading/daemon/index.html"]}}
{"query": "创建线程的方式？", "raw_response": {"answer": "Java中创建线程的方式有两种：\n1. 实现`Runnable`接口，然后让线程池执行任务。Runnable接口的方法没有返回值，适用于不需要返回结果的任务。\n示例代码如下：\n```java\nclass Task implements Runnable {\n    public String result;\n    public void run() {\n        this.result = longTimeCalculation();\n    }\n}\n```\n2. 实现`Callable`接口，可以返回指定类型的结果。Callable接口的方法有返回值，适用于需要返回结果的任务。\n示例代码如下：\n```java\nclass Task implements Callable<String> {\n    public String call() throws Exception {\n        return longTimeCalculation();\n    }\n}\n\"", "source": ["https://liaoxuefeng.com/books/java/threading/future/index.html"]}}
{"query": "Runnable 和 Callable 区别？", "raw_response": {"answer": "在Java中，`Runnable`和`Callable`都是用于多线程编程的接口，它们之间的区别在于：\n- `Runnable`接口中的`run()`方法不返回结果，且不能抛出受检异常，适合用于执行没有返回值的任务。\n- `Callable`接口中的`call()`方法可以返回结果，并且可以抛出受检异常，适合用于执行有返回值的任务。\n因此，`Runnable`适合用于执行简单的异步任务，而`Callable`适合用于执行复杂的异步任务，并且可以获取任务执行的结果。\n在提供的文档中，`RunnableAdapter`类实现了`Runnable`接口，但内部持有一个`Callable`接口的引用，通过适配器模式将`Callable`接口转换为`Runnable`接口，使得`Thread`可以接收`RunnableAdapter`对象。这种适配器模式在Java中广泛应用，用于将不同接口之间进行转换。", "source": ["https://liaoxuefeng.com/books/java/design-patterns/structural/adapter/index.html"]}}
{"query": "线程状态有哪些？", "raw_response": {"answer": "线程状态包括新建状态、就绪状态、运行状态、阻塞状态和死亡状态。", "source": ["https://liaoxuefeng.com/books/java/introduction/index.html"]}}
{"query": "sleep() 和 wait() 区别？", "raw_response": {"answer": "在Java中，sleep() 和 wait() 都可以用于线程控制，但有一些关键区别。sleep() 是Thread类的静态方法，它让当前线程暂停执行一段时间，不会释放锁。而wait() 是Object类的实例方法，它让当前线程等待，同时释放对象的锁。在使用wait()方法时，线程必须拥有对象的锁，否则会抛出IllegalMonitorStateException异常。另外，wait()方法通常和notify()或notifyAll()方法一起使用，用于线程间的通信和同步。sleep()主要用于线程间的时间控制。需要根据具体情况选择合适的方法。", "source": ["https://liaoxuefeng.com/books/java/threading/synchronize/condition/index.html"]}}
{"query": "notify() 和 notifyAll() 区别？", "raw_response": {"answer": "### 区别 between notify() 和 notifyAll()\n- **notify()** 方法会唤醒在该对象监视器上等待的单个线程。\n- **notifyAll()** 方法会唤醒在该对象监视器上等待的所有线程。\n- **notify()** 只会唤醒一个线程，而 **notifyAll()** 会唤醒所有等待的线程。\n- 使用 **notify()** 时需要注意可能会导致某些线程长时间等待，而 **notifyAll()** 则可以避免这种情况。\n- 通常情况下，更安全和可靠的做法是使用 **notifyAll()**。\n", "source": []}}
{"query": "run() 和 start() 区别？", "raw_response": {"answer": "在Java中，run() 和 start() 是用于多线程编程的重要方法。在给定的代码示例中，run() 方法定义了线程的执行逻辑，而 start() 方法用于启动新线程并执行相应的 run() 方法。直接调用 run() 方法只会在当前线程中执行，不会创建新线程；而调用 start() 方法会创建新线程并在新线程中执行 run() 方法。详细信息可以查看 [创建新线程](https://liaoxuefeng.com/books/java/threading/new-thread/index.html)。", "source": ["https://liaoxuefeng.com/books/java/threading/new-thread/index.html"]}}
{"query": "线程池创建方式？", "raw_response": {"answer": "Java中创建线程池有多种方式。可以使用Java标准库提供的线程池来执行多个任务。任务只需要实现`Runnable`接口即可让线程池执行。如果任务需要返回结果，可以使用`Callable`接口，它允许任务返回指定类型的结果。另外，频繁创建和销毁线程会消耗大量时间，因此可以使用线程池来复用一组线程，提高效率。", "source": ["https://liaoxuefeng.com/books/java/threading/future/index.html", "https://liaoxuefeng.com/books/java/threading/pool/index.html"]}}
{"query": "线程池状态有哪些？", "raw_response": {"answer": "线程池的状态包括：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED。", "source": []}}
{"query": "submit() 和 execute() 区别？", "raw_response": {"answer": "在Java中，submit() 和 execute() 是ExecutorService接口中的两个方法。submit() 方法用于提交一个Callable任务并返回一个Future对象，可以用来获取任务执行的结果或取消任务。execute() 方法用于执行一个Runnable任务，但不返回任何结果。因此，区别在于submit()可以获取任务执行结果，而execute()不能。", "source": ["https://liaoxuefeng.com/books/java/design-patterns/behavioral/chain-of-responsibility/index.html"]}}
{"query": "如何保证多线程安全？", "raw_response": {"answer": "要保证多线程安全，可以使用线程同步机制。在Java中，可以通过使用`synchronized`关键字或`Lock`接口来实现线程同步，确保多个线程访问共享资源时不会发生数据竞争和不一致性。另外，还可以使用`volatile`关键字来保证可见性和有序性。详细了解多线程同步的内容，请查阅[14.6. 线程同步](https://liaoxuefeng.com/books/java/threading/synchronize/index.html)。", "source": ["https://liaoxuefeng.com/books/java/threading/synchronize/index.html"]}}
{"query": "多线程锁的升级机制？", "raw_response": {"answer": "多线程锁的升级机制是指在多线程编程中，为了保证数据的安全性和避免竞态条件，可以采用不同级别的锁机制，如ReentrantLock、ReadWriteLock等。这些锁机制可以提供更灵活的控制和更高级别的功能，以确保线程安全和数据一致性。", "source": ["https://liaoxuefeng.com/books/java/threading/synchronize/index.html"]}}
{"query": "什么是死锁？", "raw_response": {"answer": "死锁是指多个线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致彼此无限等待的情况。在Java中，为避免死锁，线程获取锁的顺序应该保持一致。具体来说，应该严格按照先获取`lockA`，再获取`lockB`的顺序来避免死锁。如果发生死锁，没有任何机制能解除死锁，只能强制结束JVM进程。", "source": ["https://liaoxuefeng.com/books/java/threading/synchronize/dead-lock/index.html"]}}
{"query": "如何避免死锁？", "raw_response": {"answer": "要避免死锁，线程获取锁的顺序必须一致。即严格按照先获取`lockA`，再获取`lockB`的顺序。这样可以防止不同线程获取多个不同对象的锁而导致死锁。修正`dec()`方法的获取锁顺序可以有效避免死锁。", "source": ["https://liaoxuefeng.com/books/java/threading/synchronize/dead-lock/index.html"]}}
